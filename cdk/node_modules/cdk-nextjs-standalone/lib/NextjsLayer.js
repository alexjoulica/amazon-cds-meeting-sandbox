"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.NextjsLayer = void 0;
const JSII_RTTI_SYMBOL_1 = Symbol.for("jsii.rtti");
const path = require("path");
const lambda = require("aws-cdk-lib/aws-lambda");
const aws_lambda_1 = require("aws-cdk-lib/aws-lambda");
/**
 * Lambda layer for Next.js.
 * Contains Sharp 0.30.0.
 */
class NextjsLayer extends aws_lambda_1.LayerVersion {
    constructor(scope, id, props) {
        const layerDir = path.resolve(__dirname, '../assets');
        super(scope, id, {
            code: new lambda.AssetCode(path.join(layerDir, 'sharp-0.30.0.zip')),
            description: 'Sharp for Lambdas',
            ...props,
        });
        ///////  other ways to build this layer:
        // const buildDir = path.resolve(
        //   path.join(this.sstBuildDir, `NextjsLayer-${this.node.id}-${this.node.addr}`)
        // );
        // fs.removeSync(buildDir);
        // fs.mkdirSync(buildDir, { recursive: true });
        // const zipFile ="nextjs-layer.zip"
        // const zipFilePath = path.join(buildDir, zipFile);
        // const LAMBDA_FOLDER = 'nodejs'
        // const createBundleCmdArgs = [
        //   '-xc',
        //   [
        //     `mkdir -p ${LAMBDA_FOLDER}`,
        //     `cd ${LAMBDA_FOLDER}`,
        //     `npm install \
        //     --arch=x64 \
        //     --platform=linux \
        //     --target=16.15 \
        //     --libc=glibc \
        //     next sharp`,
        //     'cd ..',
        //     `zip -qr ${zipFile} ${LAMBDA_FOLDER}`
        //   ].join(' && '),
        // ];
        // const buildResult = spawn.sync('bash', createBundleCmdArgs, {
        //   cwd: buildDir,
        //   stdio: "inherit",
        // });
        // if (buildResult.status !== 0 || !fs.existsSync(zipFilePath)) {
        //   throw new Error(`Failed to create nextjs layer in ${buildDir}`);
        // }
        // // hash our parameters so we know when we need t rebuild
        // const bundleCommandHash = crypto.createHash('sha256');
        // bundleCommandHash.update(JSON.stringify(createBundleCmdArgs));
        // // bundle
        // const code = Code.fromAsset(zipFilePath);
        // // const code = Code.fromAsset(__dirname, {
        // //   // don't send all our files to docker (slow)
        // //   ignoreMode: IgnoreMode.GLOB,
        // //   exclude: ['*'],
        // //   // if our bundle commands (basically our "dockerfile") changes then rebuild the image
        // //   assetHashType: AssetHashType.CUSTOM,
        // //   assetHash: bundleCommandHash.digest('hex'),
        // //   bundling: {
        // //     image: lambda.Runtime.NODEJS_16_X.bundlingImage,
        // //     command: createBundleCommand,
        // //   },
        // // });
        // // Build Next.js layer
        // const nextjsLayer = new lambda.LayerVersion(this, "NextjsLayer", {
        //   code,
        //   compatibleRuntimes: [lambda.Runtime.NODEJS_16_X],
        //   description: "Next.js",
        // });
        // return nextjsLayer;
    }
}
exports.NextjsLayer = NextjsLayer;
_a = JSII_RTTI_SYMBOL_1;
NextjsLayer[_a] = { fqn: "cdk-nextjs-standalone.NextjsLayer", version: "2.0.3" };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTmV4dGpzTGF5ZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvTmV4dGpzTGF5ZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSw2QkFBNkI7QUFDN0IsaURBQWlEO0FBQ2pELHVEQUFzRDtBQU90RDs7O0dBR0c7QUFDSCxNQUFhLFdBQVksU0FBUSx5QkFBWTtJQUMzQyxZQUFZLEtBQWdCLEVBQUUsRUFBVSxFQUFFLEtBQXVCO1FBQy9ELE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsU0FBUyxFQUFFLFdBQVcsQ0FBQyxDQUFDO1FBQ3RELEtBQUssQ0FBQyxLQUFLLEVBQUUsRUFBRSxFQUFFO1lBQ2YsSUFBSSxFQUFFLElBQUksTUFBTSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxrQkFBa0IsQ0FBQyxDQUFDO1lBQ25FLFdBQVcsRUFBRSxtQkFBbUI7WUFDaEMsR0FBRyxLQUFLO1NBQ1QsQ0FBQyxDQUFDO1FBRUgsd0NBQXdDO1FBQ3hDLGlDQUFpQztRQUNqQyxpRkFBaUY7UUFDakYsS0FBSztRQUNMLDJCQUEyQjtRQUMzQiwrQ0FBK0M7UUFDL0Msb0NBQW9DO1FBQ3BDLG9EQUFvRDtRQUNwRCxpQ0FBaUM7UUFDakMsZ0NBQWdDO1FBQ2hDLFdBQVc7UUFDWCxNQUFNO1FBQ04sbUNBQW1DO1FBQ25DLDZCQUE2QjtRQUM3QixxQkFBcUI7UUFDckIsbUJBQW1CO1FBQ25CLHlCQUF5QjtRQUN6Qix1QkFBdUI7UUFDdkIscUJBQXFCO1FBQ3JCLG1CQUFtQjtRQUNuQixlQUFlO1FBQ2YsNENBQTRDO1FBQzVDLG9CQUFvQjtRQUNwQixLQUFLO1FBRUwsZ0VBQWdFO1FBQ2hFLG1CQUFtQjtRQUNuQixzQkFBc0I7UUFDdEIsTUFBTTtRQUNOLGlFQUFpRTtRQUNqRSxxRUFBcUU7UUFDckUsSUFBSTtRQUVKLDJEQUEyRDtRQUMzRCx5REFBeUQ7UUFDekQsaUVBQWlFO1FBRWpFLFlBQVk7UUFDWiw0Q0FBNEM7UUFFNUMsOENBQThDO1FBQzlDLG9EQUFvRDtRQUNwRCxvQ0FBb0M7UUFDcEMsdUJBQXVCO1FBRXZCLDZGQUE2RjtRQUM3Riw0Q0FBNEM7UUFDNUMsbURBQW1EO1FBRW5ELG1CQUFtQjtRQUNuQiwwREFBMEQ7UUFDMUQsdUNBQXVDO1FBQ3ZDLFVBQVU7UUFDVixTQUFTO1FBRVQseUJBQXlCO1FBQ3pCLHFFQUFxRTtRQUNyRSxVQUFVO1FBQ1Ysc0RBQXNEO1FBQ3RELDRCQUE0QjtRQUM1QixNQUFNO1FBQ04sc0JBQXNCO0lBQ3hCLENBQUM7O0FBdkVILGtDQXdFQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgKiBhcyBsYW1iZGEgZnJvbSAnYXdzLWNkay1saWIvYXdzLWxhbWJkYSc7XG5pbXBvcnQgeyBMYXllclZlcnNpb24gfSBmcm9tICdhd3MtY2RrLWxpYi9hd3MtbGFtYmRhJztcbmltcG9ydCB7IENvbnN0cnVjdCB9IGZyb20gJ2NvbnN0cnVjdHMnO1xuXG4vLyBqc2lpIGZvcmJpZHMgdGhpczpcbi8vIGV4cG9ydCBpbnRlcmZhY2UgTmV4dGpzTGF5ZXJQcm9wcyBleHRlbmRzIFBhcnRpYWw8TGF5ZXJWZXJzaW9uUHJvcHM+IHt9XG5leHBvcnQgaW50ZXJmYWNlIE5leHRqc0xheWVyUHJvcHMge31cblxuLyoqXG4gKiBMYW1iZGEgbGF5ZXIgZm9yIE5leHQuanMuXG4gKiBDb250YWlucyBTaGFycCAwLjMwLjAuXG4gKi9cbmV4cG9ydCBjbGFzcyBOZXh0anNMYXllciBleHRlbmRzIExheWVyVmVyc2lvbiB7XG4gIGNvbnN0cnVjdG9yKHNjb3BlOiBDb25zdHJ1Y3QsIGlkOiBzdHJpbmcsIHByb3BzOiBOZXh0anNMYXllclByb3BzKSB7XG4gICAgY29uc3QgbGF5ZXJEaXIgPSBwYXRoLnJlc29sdmUoX19kaXJuYW1lLCAnLi4vYXNzZXRzJyk7XG4gICAgc3VwZXIoc2NvcGUsIGlkLCB7XG4gICAgICBjb2RlOiBuZXcgbGFtYmRhLkFzc2V0Q29kZShwYXRoLmpvaW4obGF5ZXJEaXIsICdzaGFycC0wLjMwLjAuemlwJykpLFxuICAgICAgZGVzY3JpcHRpb246ICdTaGFycCBmb3IgTGFtYmRhcycsXG4gICAgICAuLi5wcm9wcyxcbiAgICB9KTtcblxuICAgIC8vLy8vLy8gIG90aGVyIHdheXMgdG8gYnVpbGQgdGhpcyBsYXllcjpcbiAgICAvLyBjb25zdCBidWlsZERpciA9IHBhdGgucmVzb2x2ZShcbiAgICAvLyAgIHBhdGguam9pbih0aGlzLnNzdEJ1aWxkRGlyLCBgTmV4dGpzTGF5ZXItJHt0aGlzLm5vZGUuaWR9LSR7dGhpcy5ub2RlLmFkZHJ9YClcbiAgICAvLyApO1xuICAgIC8vIGZzLnJlbW92ZVN5bmMoYnVpbGREaXIpO1xuICAgIC8vIGZzLm1rZGlyU3luYyhidWlsZERpciwgeyByZWN1cnNpdmU6IHRydWUgfSk7XG4gICAgLy8gY29uc3QgemlwRmlsZSA9XCJuZXh0anMtbGF5ZXIuemlwXCJcbiAgICAvLyBjb25zdCB6aXBGaWxlUGF0aCA9IHBhdGguam9pbihidWlsZERpciwgemlwRmlsZSk7XG4gICAgLy8gY29uc3QgTEFNQkRBX0ZPTERFUiA9ICdub2RlanMnXG4gICAgLy8gY29uc3QgY3JlYXRlQnVuZGxlQ21kQXJncyA9IFtcbiAgICAvLyAgICcteGMnLFxuICAgIC8vICAgW1xuICAgIC8vICAgICBgbWtkaXIgLXAgJHtMQU1CREFfRk9MREVSfWAsXG4gICAgLy8gICAgIGBjZCAke0xBTUJEQV9GT0xERVJ9YCxcbiAgICAvLyAgICAgYG5wbSBpbnN0YWxsIFxcXG4gICAgLy8gICAgIC0tYXJjaD14NjQgXFxcbiAgICAvLyAgICAgLS1wbGF0Zm9ybT1saW51eCBcXFxuICAgIC8vICAgICAtLXRhcmdldD0xNi4xNSBcXFxuICAgIC8vICAgICAtLWxpYmM9Z2xpYmMgXFxcbiAgICAvLyAgICAgbmV4dCBzaGFycGAsXG4gICAgLy8gICAgICdjZCAuLicsXG4gICAgLy8gICAgIGB6aXAgLXFyICR7emlwRmlsZX0gJHtMQU1CREFfRk9MREVSfWBcbiAgICAvLyAgIF0uam9pbignICYmICcpLFxuICAgIC8vIF07XG5cbiAgICAvLyBjb25zdCBidWlsZFJlc3VsdCA9IHNwYXduLnN5bmMoJ2Jhc2gnLCBjcmVhdGVCdW5kbGVDbWRBcmdzLCB7XG4gICAgLy8gICBjd2Q6IGJ1aWxkRGlyLFxuICAgIC8vICAgc3RkaW86IFwiaW5oZXJpdFwiLFxuICAgIC8vIH0pO1xuICAgIC8vIGlmIChidWlsZFJlc3VsdC5zdGF0dXMgIT09IDAgfHwgIWZzLmV4aXN0c1N5bmMoemlwRmlsZVBhdGgpKSB7XG4gICAgLy8gICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBjcmVhdGUgbmV4dGpzIGxheWVyIGluICR7YnVpbGREaXJ9YCk7XG4gICAgLy8gfVxuXG4gICAgLy8gLy8gaGFzaCBvdXIgcGFyYW1ldGVycyBzbyB3ZSBrbm93IHdoZW4gd2UgbmVlZCB0IHJlYnVpbGRcbiAgICAvLyBjb25zdCBidW5kbGVDb21tYW5kSGFzaCA9IGNyeXB0by5jcmVhdGVIYXNoKCdzaGEyNTYnKTtcbiAgICAvLyBidW5kbGVDb21tYW5kSGFzaC51cGRhdGUoSlNPTi5zdHJpbmdpZnkoY3JlYXRlQnVuZGxlQ21kQXJncykpO1xuXG4gICAgLy8gLy8gYnVuZGxlXG4gICAgLy8gY29uc3QgY29kZSA9IENvZGUuZnJvbUFzc2V0KHppcEZpbGVQYXRoKTtcblxuICAgIC8vIC8vIGNvbnN0IGNvZGUgPSBDb2RlLmZyb21Bc3NldChfX2Rpcm5hbWUsIHtcbiAgICAvLyAvLyAgIC8vIGRvbid0IHNlbmQgYWxsIG91ciBmaWxlcyB0byBkb2NrZXIgKHNsb3cpXG4gICAgLy8gLy8gICBpZ25vcmVNb2RlOiBJZ25vcmVNb2RlLkdMT0IsXG4gICAgLy8gLy8gICBleGNsdWRlOiBbJyonXSxcblxuICAgIC8vIC8vICAgLy8gaWYgb3VyIGJ1bmRsZSBjb21tYW5kcyAoYmFzaWNhbGx5IG91ciBcImRvY2tlcmZpbGVcIikgY2hhbmdlcyB0aGVuIHJlYnVpbGQgdGhlIGltYWdlXG4gICAgLy8gLy8gICBhc3NldEhhc2hUeXBlOiBBc3NldEhhc2hUeXBlLkNVU1RPTSxcbiAgICAvLyAvLyAgIGFzc2V0SGFzaDogYnVuZGxlQ29tbWFuZEhhc2guZGlnZXN0KCdoZXgnKSxcblxuICAgIC8vIC8vICAgYnVuZGxpbmc6IHtcbiAgICAvLyAvLyAgICAgaW1hZ2U6IGxhbWJkYS5SdW50aW1lLk5PREVKU18xNl9YLmJ1bmRsaW5nSW1hZ2UsXG4gICAgLy8gLy8gICAgIGNvbW1hbmQ6IGNyZWF0ZUJ1bmRsZUNvbW1hbmQsXG4gICAgLy8gLy8gICB9LFxuICAgIC8vIC8vIH0pO1xuXG4gICAgLy8gLy8gQnVpbGQgTmV4dC5qcyBsYXllclxuICAgIC8vIGNvbnN0IG5leHRqc0xheWVyID0gbmV3IGxhbWJkYS5MYXllclZlcnNpb24odGhpcywgXCJOZXh0anNMYXllclwiLCB7XG4gICAgLy8gICBjb2RlLFxuICAgIC8vICAgY29tcGF0aWJsZVJ1bnRpbWVzOiBbbGFtYmRhLlJ1bnRpbWUuTk9ERUpTXzE2X1hdLFxuICAgIC8vICAgZGVzY3JpcHRpb246IFwiTmV4dC5qc1wiLFxuICAgIC8vIH0pO1xuICAgIC8vIHJldHVybiBuZXh0anNMYXllcjtcbiAgfVxufVxuIl19